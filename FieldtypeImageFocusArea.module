<?php

/**
 * FieldtypeImageFocusArea for ProcessWire
 *
 * Extends InputfieldImage with the option to store focus data
 *
 * @author Philipp Schreier @phlppschrr <git@rgb10.de>
 * @copyright Copyright (c) 2013-2014, Philipp Schreier
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 *
 * ProcessWire 2.x
 * Copyright (C) 2014 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 *
 */
class FieldtypeImageFocusArea extends FieldtypeImage implements ConfigurableModule
{

    public static function getModuleInfo()
    {
        return array(
                'title' => __('Images FocusArea Fieldtype', __FILE__),
                'summary' => __('Extends FieldtypeImage with the option to store focus data', __FILE__),
                'version' => '0.5.1',
                'author' => "Philipp Schreier (interrobang)",
                'icon' => 'crosshairs',
                'singular' => false,
                'autoload' => false,
        );
    }

    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData()
    {
        return array(
                'schema_version' => 1,
        );
    }

    /**
     * Name and latest schema version for database table used by this module
     *
     */
    const SCHEMA_VERSION = 2;


    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct()
    {
        parent::__construct();
        foreach (self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }


    public function init()
    {
//        $this->message('current database schema ' . $this->schema_version);
//        // update database schema (if not the latest one yet)
//        if ($this->schema_version < self::SCHEMA_VERSION) {
//            $this->updateDatabaseSchema();
//        }

        $this->defaultInputfieldClass = 'InputfieldImageFocusArea';

        $this->addHookBefore('Pageimage::size', $this, 'hookPageimageSize');
        $this->addHook('Pageimage::getNamedCrop', $this, 'getNamedCrop');
        $this->addHookProperty("Pageimage::cssBackgroundPosition", $this, "cssBackgroundPosition");
    }


    public static function getModuleConfigInputfields(array $data)
    {
        //TODO add some config options?
        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);
        return $fields;
    }


    public function hookPageimageSize(HookEvent $event)
    {
        $pageImage = $event->object;

        if ($pageImage->focus) {


            $argumentOptions = $event->arguments('options');
            $configOptions = wire('config')->imageSizerOptions;
            if (!is_array($configOptions)) {
                $configOptions = array();
            }

            if (!is_array($argumentOptions)) {
                if (is_string($argumentOptions)) {
                    // optionally allow a string to be specified with crop direction, for shorter syntax
                    if (strpos($argumentOptions, ',') !== false) {
                        $argumentOptions = explode(',', $argumentOptions);
                    }
                    $argumentOptions = array('cropping' => $argumentOptions);
                } else {
                    if (is_int($argumentOptions)) {
                        // optionally allow an integer to be specified with quality, for shorter syntax
                        $argumentOptions = array('quality' => $argumentOptions);
                    } else {
                        if (is_bool($argumentOptions)) {
                            // optionally allow a boolean to be specified with upscaling toggle on/off
                            $argumentOptions = array('upscaling' => $argumentOptions);
                        }
                    }
                }
            }

            $allFocusSettings = json_decode($pageImage->focus);
            if (isset($argumentOptions['namedCrop'])) {
                $focusName = $argumentOptions['namedCrop'];
            } else {
                $focusName = 'focus';
            }
            $focusSettings = isset($allFocusSettings->$focusName) ? $allFocusSettings->$focusName : false;

            if (!$focusSettings && $focusName != 'focus') {
                // fallback to default "focus" for unconfigured thumbnails
                $focusSettings = isset($allFocusSettings->focus) ? $allFocusSettings->focus : false;
                if (!$focusSettings) {
                    return;
                }
            }

            $defaultOptions = array(
                    'upscaling' => true,
                    'cropping' => true,
                    'quality' => 90,
                    'suffix' => array(), // can be array of suffixes or string of 1 suffix
                    'forceNew' => false,  // force it to create new image even if already exists
            );

            $configOptions = wire('config')->imageSizerOptions;
            if (!is_array($configOptions)) {
                $configOptions = array();
            }
            $mergedOptions = array_merge($defaultOptions, $configOptions, $argumentOptions);


            if (!isset($argumentOptions['cropping'])) {
                // TODO: default focusMode 'align', make this configuarable?
                // No, align or center, the other options interfere with Richtext-Editor imagesizing
                $focusMode = 'align';
                return;
//                $croppingSet = isset($argumentOptions['cropping']) ? 'ja':'nein';

            } elseif (in_array($argumentOptions['cropping'], array('align', 'inside', 'outside'), true)) {
                // a valid cropping option for this field was found
                $focusMode = $argumentOptions['cropping'];
            } else {
                // use the user set cropping option, nothing to do for us
                return;
            }

            $targetWidth = $event->arguments('width');
            $targetHeight = $event->arguments('height');
            $originalWidth = $pageImage->width();
            $originalHeight = $pageImage->height();


            $cropping = array();
            $cropping[0] = ((($focusSettings->x + $focusSettings->x2) / 2) / $originalWidth) * 100 . '%';
            $cropping[1] = ((($focusSettings->y + $focusSettings->y2) / 2) / $originalHeight) * 100 . '%';


            switch ($focusMode) {
                case 'align':
                    // use center of croppingBox for alignment
                    $argumentOptions['cropping'] = $cropping;
                    break;

                case 'inside':
                    $cropExtra = array(
                            'x' => (int) $focusSettings->x,
                            'y' => (int) $focusSettings->y,
                            'w' => (int) $focusSettings->w,
                            'h' => (int) $focusSettings->h
                    );
                    $argumentOptions['cropExtra'] = $cropExtra;
                    // use default (center) cropping on the remaining image:
                    unset($argumentOptions['cropping']);
                    break;

                case 'outside':

                    if ($targetHeight == 0) {
                        $targetHeight = ($focusSettings->w / $targetWidth) * $focusSettings->h;
                    }

                    if (($targetWidth / $targetHeight) > ($focusSettings->w / $focusSettings->h)) {

                        $cropExtra = array(
                                'x' => 0,
                                'y' => (int) $focusSettings->y,
                                'w' => (int) $originalWidth,
                                'h' => (int) $focusSettings->h
                        );

                        // should we do this only if upscaling=false?
                        if ($targetHeight > $focusSettings->h) {
                            $halfMissingHeight = ($targetHeight - $focusSettings->h) / 2;

                            if ($targetHeight >= $originalHeight) {
                                // expand height to maximum
                                $cropExtra['y'] = 0;
                                $cropExtra['h'] = (int) $originalHeight;
                            } elseif ($focusSettings->y - $halfMissingHeight >= 0 &&
                                    $focusSettings->y2 + $halfMissingHeight < $originalHeight
                            ) {
                                // we can expand the focusArea in both directions
                                $cropExtra['y'] = (int) ($focusSettings->y - $halfMissingHeight);
                                $cropExtra['h'] = (int) $targetHeight;
                            } else {
                                // the focusArea can't be expanded equally to both directions
                                $cropExtra['h'] = $targetHeight;
                                if ($focusSettings->y - $halfMissingHeight < 0) {
                                    $cropExtra['y'] = 0;
                                } else {
                                    $cropExtra['y'] = (int) ($originalHeight - $targetHeight);
                                }

                            }
                        }
                    } else {
                        $cropExtra = array(
                                'x' => (int) $focusSettings->x,
                                'y' => 0,
                                'w' => (int) $focusSettings->w,
                                'h' => (int) $originalHeight
                        );
                        // should we do this only if upscaling=false?
                        if ($targetWidth > $focusSettings->w) {
                            $halfMissingWidth = ($targetWidth - $focusSettings->w) / 2;

                            if ($targetWidth >= $originalWidth) {
                                // expand height to maximum
                                $cropExtra['x'] = 0;
                                $cropExtra['w'] = (int) $originalWidth;
                            } elseif ($focusSettings->x - $halfMissingWidth >= 0 &&
                                    $focusSettings->x2 + $halfMissingWidth < $originalWidth
                            ) {
                                // we can expand the focusArea in both directions
                                $cropExtra['x'] = (int) ($focusSettings->x - $halfMissingWidth);
                                $cropExtra['w'] = (int) $targetWidth;
                            } else {
                                // the focusArea can't be expanded equally to both directions
                                $cropExtra['w'] = $targetWidth;
                                if ($focusSettings->x - $halfMissingWidth < 0) {
                                    $cropExtra['x'] = 0;
                                } else {
                                    $cropExtra['x'] = (int) ($originalWidth - $targetWidth);
                                }

                            }
                        }
                    }
                    $argumentOptions['cropExtra'] = $cropExtra;
                    $argumentOptions['cropping'] = $cropping;
                    break;
            }
            // Automatically set filename suffix to the same name as the $focusmode/cropping to avoid caching issues as discussed here:
            // https://processwire.com/talk/topic/8079-imagefocusarea/?p=78439
            if ($focusMode) {

//                $suffix = $focusMode;
//                $suffix .= isset($argumentOptions["suffix"]) ? '-' . $argumentOptions["suffix"] : '';    // $options is the options
//                $argumentOptions['suffix'] = $suffix;

                array_multisort($argumentOptions);
                $hash = md5(json_encode($argumentOptions));

                $suffix = substr($hash, 0, 8);;
                $suffix .= isset($argumentOptions["suffix"]) ? '-' . $argumentOptions["suffix"] : '';    // $options is the options
                $argumentOptions['suffix'] = $suffix;

                $event->arguments('options', $argumentOptions);
            }
        }
    }

    /**
     * experimental approach to calculate a background-position for using together with background-position:cover
     *
     * @param HookEvent $event
     */
    public function cssBackgroundPosition(HookEvent $event)
    {
        $pageImage = $event->object;
        $pos = '50% 50%';
        if ($pageImage->focus) {

            $originalWidth = $pageImage->width();
            $originalHeight = $pageImage->height();
            $centerX = $originalWidth / 2;
            $centerY = $originalHeight / 2;
            $argumentOptions = $event->arguments(0);

            $allFocusSettings = json_decode($pageImage->focus);
            if (isset($argumentOptions['namedCrop'])) {
                $focusName = $argumentOptions['namedCrop'];
            } else {
                $focusName = 'focus';
            }
            $focusSettings = $allFocusSettings->$focusName;



            // horizontal position
            if ($focusSettings->x < $centerX && $focusSettings->x2 <= $centerX) {
                // align focusArea left
                $posX = ($focusSettings->x / $originalWidth) * 100 . '%';
            } elseif ($focusSettings->x < $centerX && $focusSettings->x2 >= $centerX) {
                // align focusArea center
                $posX = ((($focusSettings->x + $focusSettings->x2) / 2) / $originalWidth) * 100 . '%';
            } else {
                // align focusArea right
                $posX = ($focusSettings->x2 / $originalWidth) * 100 . '%';
            }

            // vertical position
            if ($focusSettings->y < $centerY && $focusSettings->y2 <= $centerY) {
                // align focusArea top
                $posY = ($focusSettings->y / $originalHeight) * 100 . '%';
            } elseif ($focusSettings->y < $centerY && $focusSettings->y2 >= $centerY) {
                // align focusArea center
                $posY = ((($focusSettings->y + $focusSettings->y2) / 2) / $originalHeight) * 100 . '%';
            } else {
                // align focusArea right
                $posY = ($focusSettings->y2 / $originalHeight) * 100 . '%';
            }

            $pos = $posX . ' ' . $posY;
        }
        $event->return = $pos;
    }

    // copied from FieldtypeCropimage
    public function getNamedCrop(HookEvent $event)
    {
        $pageImage = $event->object;
        $thumbFound = false;
        $cropName = $event->arguments[0];

        // return InputfieldCropImage or null if not found
        /** @var InputfieldImageFocusArea $inputFieldInstance */
        $inputFieldInstance = $this->_getInputFieldInstance($event);

        //TODO Wieso return true?
        if (!$inputFieldInstance) {
            return true;
        }

        // read crop settings from InputfieldCropImage
        $crops = $inputFieldInstance->cropSettings;

        // and we continue...
        $crops_a = explode("\n", $crops); // ie. thumbname,200,200 (name,width,height)

        foreach ($crops_a as $crop) {
            $crop = explode(",", $crop);
            if ($crop[0] == $cropName) {
                $cropSettingWidth = (int) $crop[1];
                $cropSettingHeight = (int) $crop[2];
                $thumbFound = true;
                break;
            }
        }

        if ($thumbFound === false) {
            throw new WireException(sprintf($this->_("There is no thumb called: %s"), $cropName));
            return;
        }

        if ($cropSettingWidth < 1 && $cropSettingHeight < 1) {
            //TODO evtl ein freeform crop anbieten = genauso wie bei standard focusArea
            throw new WireException(sprintf($this->_("Width and height not found for thumb: %s"), $cropName));
            return;
        }

        $width = $cropSettingWidth;
        $height = $cropSettingHeight;
        $argumentOptions = $event->arguments(1);
        if(!is_array($argumentOptions)){
            $argumentOptions = array();
        }

//        if (is_array($argumentOptions)) {
            if (isset($argumentOptions['width']) && (int) $argumentOptions['width'] > 0 && isset($argumentOptions['height']) && (int) $argumentOptions['height'] > 0) {
                //TODO better error message explaining whats wrong
                throw new WireException(sprintf($this->_("only width or height allowed for namedCrop"), $cropName));
            }
            if (isset($argumentOptions['width']) && (int) $argumentOptions['width'] > 0) {
                $width = (int) $argumentOptions['width'];
                $height = (int) ($width * ($cropSettingHeight / $cropSettingWidth));
                unset($argumentOptions['width']);
            }
            if (isset($argumentOptions['height']) && (int) $argumentOptions['height'] > 0) {
                $height = (int) $argumentOptions['height'];
                $width = (int) ($height * ($cropSettingWidth / $cropSettingHeight));
                unset($argumentOptions['height']);
            }
//        }

        $mergedOptions = array_merge($argumentOptions, array('cropping' => 'inside', 'namedCrop' => $cropName));
        $event->return = $pageImage->size($width, $height, $mergedOptions);
    }

    // modified from fieldtype cropimage
    public function _getInputFieldInstance(HookEvent $event)
    {
        $field = null; // where we'll keep the field we're looking for
        $image = $event->object;
        $page = $image->page;
        $action = $event->arguments[0];

        // find all fields of type FieldtypeImage that are part of the page we're using
        // or regular image fields with InputfieldImage inputfield assigned
        $imageFields = array();
        foreach ($page->fields as $f) {
            // TODO: is this legacy code or still needed?
            // if ($f->type instanceof FieldtypeImageFocusArea || ($f->inputfieldClass && $f->inputfieldClass == 'InputfieldCropImage')) {
            if ($f->type instanceof FieldtypeImageFocusArea) {
                $imageFields[] = $f;
            }
        }

        // loop through to find the one we're looking for
        foreach ($imageFields as $imageField) {

            // good to get unformatted in case it's a single image field,
            // because it'll still be an array rather than 1 image
            $pagefiles = $page->getUnformatted($imageField->name);


            // if the image's pagefiles property matches the one with the
            // field we're looking at, we have a match. save in $field
            if ($image->pagefiles === $pagefiles) {
                $field = $imageField->getInputfield($page);
                break;
            }
        }

        if ($field) {
            return $field;
        }

        return null;
    }

    /**
     * Return the DB schema used by this field's table
     *
     */
    public function getDatabaseSchema(Field $field)
    {
        $schema = parent::getDatabaseSchema($field);
//        $schema['focus'] = 'varchar(255) NOT NULL';
        $schema['focus'] = 'text NOT NULL';
        $schema['keys']['focus'] = 'FULLTEXT KEY focus (focus)';
        return $schema;
    }


    /**
     * Update database schema
     *
     * This method applies incremental updates until latest schema version is
     * reached, while also keeping schema_version config setting up to date.
     *
     */
    /*
    private function updateDatabaseSchema()
    {
        return;
//        $table_name = 'field_' . $this->name;
//        $this->warning('updateDatabaseSchema '. $this->name);
//        if(!$this->name) return;

        while ($this->schema_version < self::SCHEMA_VERSION) {
            ++$this->schema_version;
            switch ($this->schema_version) {
                case 2:
                    $sql = "ALTER TABLE " . $table_name . " CHANGE `focus` `focus` TEXT NOT NULL";
                    break;
                default:
                    throw new WireException("Unrecognized database schema version: $this->schema_version");
            }
            if ($sql && $this->db->query($sql)) {
                $configData = $this->modules->getModuleConfigData($this);
                $configData['schema_version'] = $this->schema_version;
                $this->modules->saveModuleConfigData($this, $configData);
                $this->warning('updated database schema to version ' . $this->schema_version);
            } else {
                throw new WireException("Couldn't update database schema to version $this->schema_version");
            }
        }
    }
*/

    /**
     * Given a raw value (value as stored in DB), return the value as it would appear in a Page object
     *
     * @param Page $page
     * @param Field $field
     * @param string|int|array $value
     *
     * @return string|int|array|object $value
     *
     */
    public function ___wakeupValue(Page $page, Field $field, $value)
    {

        $pagefiles = parent::___wakeupValue($page, $field, $value);

        foreach ($pagefiles as $pagefile) {
            foreach ($value as $v) {
                if ($v['data'] != $pagefile->basename) {
                    continue;
                }
                $pagefile->set('focus', $v['focus']);
            }
        }

        $pagefiles->resetTrackChanges(true);

        return $pagefiles;
    }

    /**
     * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB.
     *
     * @param Page $page
     * @param Field $field
     * @param string|int|array|object $value
     *
     * @return string|int
     *
     */
    public function ___sleepValue(Page $page, Field $field, $value)
    {
        $sleepValue = parent::___sleepValue($page, $field, $value);
        if (!$value instanceof Pagefiles) {
            return $sleepValue;
        }

        $key = 0;
        foreach ($value as $item) {
            $sleepValue[$key]['focus'] = $value[$sleepValue[$key]['data']]->focus;
            $key++;
        }
        return $sleepValue;
    }

}

