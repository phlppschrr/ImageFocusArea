<?php

/**
 * FieldtypeImageFocusArea for ProcessWire
 *
 * Extends InputfieldImage with the option to store focus data
 *
 * @author Philipp Schreier @phlppschrr <git@rgb10.de>
 * @copyright Copyright (c) 2013-2014, Philipp Schreier
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 *
 * ProcessWire 2.x
 * Copyright (C) 2014 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 *
 */
class FieldtypeImageFocusArea extends FieldtypeImage implements ConfigurableModule
{

    public static function getModuleInfo()
    {
        return array(
                'title' => __('Images FocusArea Fieldtype', __FILE__),
                'summary' => __('Extends FieldtypeImage with the option to store focus data', __FILE__),
                'version' => '0.6.0',
                'author' => "Philipp Schreier (interrobang)",
                'icon' => 'crosshairs',
                'singular' => false,
                'autoload' => false,
        );
    }

    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData()
    {
        return array(
                'schema_version' => 1,
        );
    }

    /**
     * Name and latest schema version for database table used by this module
     *
     */
    const SCHEMA_VERSION = 2;


    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct()
    {
        parent::__construct();
        foreach (self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }


    public function init()
    {
//        $this->message('current database schema ' . $this->schema_version);
//        // update database schema (if not the latest one yet)
//        if ($this->schema_version < self::SCHEMA_VERSION) {
//            $this->updateDatabaseSchema();
//        }

        $this->defaultInputfieldClass = 'InputfieldImageFocusArea';

        $this->addHookBefore('Pageimage::size', $this, 'hookPageimageSize');
        $this->addHook('Pageimage::getNamedCrop', $this, 'getNamedCrop');
        /* TODO additionalHooks?
        crop => cropping=inside
        cropInside => cropping=inside
        cropOutside => cropping=outside
        cropAlign => cropping=align
        widthInside
        widthOutside
        widthAlign
        ...
        */

        $this->addHookProperty("Pageimage::cssBackgroundPosition", $this, "cssBackgroundPosition");
    }


    public static function getModuleConfigInputfields(array $data)
    {
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
//        $modules = wire('modules');

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);
        return $fields;
    }


    public function hookPageimageSize(HookEvent $event)
    {
        $pageImage = $event->object;

        if ($pageImage->focus) {

            $options = $event->arguments('options');
            $options = $this->sanitizePageImageOptions($options);

            $focusSettings = $this->getFocusSettings($pageImage, $options);
            if (!$focusSettings) return;

            $defaultOptions = array(
                    'upscaling' => true,
                    'cropping' => true,
                    'quality' => 90,
                    'suffix' => array(), // can be array of suffixes or string of 1 suffix
                    'forceNew' => false,  // force it to create new image even if already exists
            );

            // fallback to 'align' cropping
            if (!isset($options['cropping'])) $options['cropping'] = 'align';

            if (in_array($options['cropping'], array('align', 'inside', 'outside'), true)) {
                // a valid cropping option for this field was found
                $focusMode = $options['cropping'];
            } else {
                // use the user set cropping option, nothing to do for us
                return;
            }

            $targetWidth = $event->arguments('width');
            $targetHeight = $event->arguments('height');
            $originalWidth = $pageImage->width();
            $originalHeight = $pageImage->height();

            $cropping = array();
            $cropping[0] = ((($focusSettings['x'] + $focusSettings['x2']) / 2) / $originalWidth) * 100 . '%';
            $cropping[1] = ((($focusSettings['y'] + $focusSettings['y2']) / 2) / $originalHeight) * 100 . '%';


            switch ($focusMode) {
                case 'align':
                    // use center of croppingBox for alignment
                    $options['cropping'] = $cropping;
                    break;

                case 'inside':
                    $cropExtra = array(
                            'x' => (int) $focusSettings['x'],
                            'y' => (int) $focusSettings['y'],
                            'w' => (int) $focusSettings['w'],
                            'h' => (int) $focusSettings['h']
                    );
                    $options['cropExtra'] = $cropExtra;
                    // use default (center) cropping on the remaining image:
                    unset($options['cropping']);
                    break;

                case 'outside':

                    if ($targetHeight == 0) {
                        $targetHeight = ($focusSettings['w'] / $targetWidth) * $focusSettings['h'];
                    }

                    if (($targetWidth / $targetHeight) > ($focusSettings['w'] / $focusSettings['h'])) {

                        $cropExtra = array(
                                'x' => 0,
                                'y' => (int) $focusSettings['y'],
                                'w' => (int) $originalWidth,
                                'h' => (int) $focusSettings['h']
                        );

                        if ($targetHeight > $focusSettings['h']) {
                            $halfMissingHeight = ($targetHeight - $focusSettings['h']) / 2;

                            if ($targetHeight >= $originalHeight) {
                                // expand height to maximum
                                $cropExtra['y'] = 0;
                                $cropExtra['h'] = (int) $originalHeight;
                            } elseif ($focusSettings['y'] - $halfMissingHeight >= 0 &&
                                    $focusSettings['y2'] + $halfMissingHeight < $originalHeight
                            ) {
                                // we can expand the focusArea in both directions
                                $cropExtra['y'] = (int) ($focusSettings['y'] - $halfMissingHeight);
                                $cropExtra['h'] = (int) $targetHeight;
                            } else {
                                // the focusArea can't be expanded equally to both directions
                                $cropExtra['h'] = $targetHeight;
                                if ($focusSettings['y'] - $halfMissingHeight < 0) {
                                    $cropExtra['y'] = 0;
                                } else {
                                    $cropExtra['y'] = (int) ($originalHeight - $targetHeight);
                                }

                            }
                        }
                    } else {
                        $cropExtra = array(
                                'x' => (int) $focusSettings['x'],
                                'y' => 0,
                                'w' => (int) $focusSettings['w'],
                                'h' => (int) $originalHeight
                        );

                        if ($targetWidth > $focusSettings['w']) {
                            $halfMissingWidth = ($targetWidth - $focusSettings['w']) / 2;

                            if ($targetWidth >= $originalWidth) {
                                // expand height to maximum
                                $cropExtra['x'] = 0;
                                $cropExtra['w'] = (int) $originalWidth;
                            } elseif ($focusSettings['x'] - $halfMissingWidth >= 0 &&
                                    $focusSettings['x2'] + $halfMissingWidth < $originalWidth
                            ) {
                                // we can expand the focusArea in both directions
                                $cropExtra['x'] = (int) ($focusSettings['x'] - $halfMissingWidth);
                                $cropExtra['w'] = (int) $targetWidth;
                            } else {
                                // the focusArea can't be expanded equally to both directions
                                $cropExtra['w'] = $targetWidth;
                                if ($focusSettings['x'] - $halfMissingWidth < 0) {
                                    $cropExtra['x'] = 0;
                                } else {
                                    $cropExtra['x'] = (int) ($originalWidth - $targetWidth);
                                }

                            }
                        }
                    }
                    $options['cropExtra'] = $cropExtra;
                    $options['cropping'] = $cropping;
                    break;
            }

            // Automatically set filename suffix to the same name as the $focusmode/cropping to avoid caching issues as discussed here:
            // https://processwire.com/talk/topic/8079-imagefocusarea/?p=78439

            $configOptions = wire('config')->imageSizerOptions;
            if (!is_array($configOptions)) $configOptions = array();

            $mergedOptions = array_merge($defaultOptions, $configOptions, $options);
//                $suffix = $focusMode;
//                $suffix .= isset($argumentOptions["suffix"]) ? '-' . $argumentOptions["suffix"] : '';    // $options is the options
//                $argumentOptions['suffix'] = $suffix;

            $hashOptions = array();
            if(isset($mergedOptions['cropExtra'])) $hashOptions['cropExtra'] = $mergedOptions['cropExtra'];
            if(isset($mergedOptions['upscaling'])) $hashOptions['upscaling'] = $mergedOptions['upscaling'];
            if(isset($mergedOptions['quality'])) $hashOptions['quality'] = $mergedOptions['quality'];
            if(isset($mergedOptions['sharpening'])) $hashOptions['sharpening'] = $mergedOptions['sharpening'];
            $hash = md5(json_encode($hashOptions));

            $suffix = substr($hash, 0, 8);;
            $suffix .= isset($options["suffix"]) ? '-' . $options["suffix"] : '';    // $options is the options
            $options['suffix'] = $suffix;

            $event->arguments('options', $options);
        }
    }


    /**
     * experimental approach to calculate a background-position for using together with background-position:cover
     *
     * @param HookEvent $event
     */
    public function cssBackgroundPosition(HookEvent $event)
    {
        $pageImage = $event->object;
        $pos = '50% 50%';
        if ($pageImage->focus) {

            $originalWidth = $pageImage->width();
            $originalHeight = $pageImage->height();
            $centerX = $originalWidth / 2;
            $centerY = $originalHeight / 2;
            $argumentOptions = $event->arguments(0);
            if(!is_array($argumentOptions)) $argumentOptions= array();
            $focusSettings = $this->getFocusSettings($pageImage, $argumentOptions);

            // horizontal position
            if ($focusSettings['x'] < $centerX && $focusSettings['x2'] <= $centerX) {
                // align focusArea left
                $posX = ($focusSettings['x'] / $originalWidth) * 100 . '%';
            } elseif ($focusSettings['x'] < $centerX && $focusSettings['x2'] >= $centerX) {
                // align focusArea center
                $posX = ((($focusSettings['x'] + $focusSettings['x2']) / 2) / $originalWidth) * 100 . '%';
            } else {
                // align focusArea right
                $posX = ($focusSettings['x2'] / $originalWidth) * 100 . '%';
            }

            // vertical position
            if ($focusSettings['y'] < $centerY && $focusSettings['y2'] <= $centerY) {
                // align focusArea top
                $posY = ($focusSettings['y'] / $originalHeight) * 100 . '%';
            } elseif ($focusSettings['y'] < $centerY && $focusSettings['y2'] >= $centerY) {
                // align focusArea center
                $posY = ((($focusSettings['y'] + $focusSettings['y2']) / 2) / $originalHeight) * 100 . '%';
            } else {
                // align focusArea right
                $posY = ($focusSettings['y2'] / $originalHeight) * 100 . '%';
            }

            $pos = $posX . ' ' . $posY;
        }
        $event->return = $pos;
    }


    // copied/modified from FieldtypeCropimage
    public function getNamedCrop(HookEvent $event)
    {
        $pageImage = $event->object;
        $options = $event->arguments(1);
        if(!is_array($options)) $options = array();

        $thumbFound = false;
        $cropName = $event->arguments[0];
        $inputFieldInstance = $this->getInputFieldInstance($pageImage);

        // read crop settings from InputfieldCropImage
        $crops = $inputFieldInstance->cropSettings;

        // and we continue...
        $crops_a = explode("\n", $crops); // ie. thumbname,200,200 (name,width,height)

        foreach ($crops_a as $crop) {
            $crop = explode(",", $crop);
            if (count($crop)>=3 && trim($crop[0]) == $cropName) {
                $cropSettingWidth = (int) $crop[1];
                $cropSettingHeight = (int) $crop[2];
                $thumbFound = true;
                break;
            }
        }

        if ($thumbFound === false) {
            throw new WireException(sprintf($this->_("There is no thumb called: %s"), $cropName));
        }

        if ($cropSettingWidth < 1 && $cropSettingHeight < 1) {
            // crop without aspectratio
            $options['cropset'] = $cropName;
            $focusSettings = $this->getFocusSettings($pageImage, $options);
            if (isset($focusSettings['w']) && isset($focusSettings['h'])) {
                $cropSettingWidth = (int)$focusSettings['w'];
                $cropSettingHeight = (int)$focusSettings['h'];
            } else {
                $cropSettingWidth = $pageImage->width;
                $cropSettingHeight = $pageImage->height;
            }
        }

        $width = $cropSettingWidth;
        $height = $cropSettingHeight;

        if (isset($options['width']) && (int)$options['width'] > 0
            && isset($options['height']) && (int)$options['height'] > 0) {
            //TODO better error message explaining whats wrong? Or allow width AND height and return a cropped inside image?
            throw new WireException(sprintf($this->_("only width OR height allowed for cropset: %s"), $cropName));
        }
        if (isset($options['width']) && (int)$options['width'] > 0) {
            $width = (int)$options['width'];
            $height = (int)($width * ($cropSettingHeight / $cropSettingWidth));
            unset($options['width']);
        }
        if (isset($options['height']) && (int)$options['height'] > 0) {
            $height = (int)$options['height'];
            $width = (int)($height * ($cropSettingWidth / $cropSettingHeight));
            unset($options['height']);
        }

        $mergedOptions = array_merge($options, array('cropping' => 'inside', 'cropset' => $cropName));
        $event->return = $pageImage->size($width, $height, $mergedOptions);
    }


    /**
     * @param $options
     * @return array
     */
    protected function sanitizePageImageOptions($options){
        if(!is_array($options)) {
            if(is_string($options)) {
                // optionally allow a string to be specified with crop direction, for shorter syntax
                if(strpos($options, ',') !== false) $options = explode(',', $options); // 30,40
                $options = array('cropping' => $options);
            } else if(is_int($options)) {
                // optionally allow an integer to be specified with quality, for shorter syntax
                $options = array('quality' => $options);
            } else if(is_bool($options)) {
                // optionally allow a boolean to be specified with upscaling toggle on/off
                $options = array('upscaling' => $options);
            }
        }
        return $options;
    }


    /**
     * @param Pageimage $pageImage
     * @param array $options
     * @return array|bool
     */
    protected function getFocusSettings(Pageimage $pageImage, array $options){
        /** @var array $allFocusSettings */
        $allFocusSettings = json_decode($pageImage->focus, true);
        // fallback to default "focus" for unconfigured thumbnails
        $cropset = isset($options['cropset']) ? $options['cropset']:'focus';

        $focusSettings = false;
        if (is_string($cropset)) {
            $focusSettings = isset($allFocusSettings[$cropset]) ? $allFocusSettings[$cropset] : false;
        } elseif(is_array($cropset)){
            $focusSettings = $cropset;
        }
        return $focusSettings;
    }


    // modified from fieldtype cropimage
    /**
     * @param HookEvent $event
     * @param bool $useFieldgroupContext If set to true, the field will be a clone of the original with context data set. (default is false)
     * @return Inputfield|null
     */
    protected function getInputFieldInstance(Pagefile $pageFile, $useFieldgroupContext = true)
    {
        $file = $pageFile;
        $page = $file->page;
        $classname = get_class();

        // find all fields of type FieldtypeImageFocusArea that are part of the page we're using
        $imageFields = array();
        foreach ($page->fields as $f) {
            if ($f->type instanceof FieldtypeImageFocusArea) {
                $imageFields[] = $f;
            }
        }

        // loop through to find the one we're looking for
        foreach ($imageFields as $imageField) {

            // good to get unformatted in case it's a single image field,  because it'll still be an array rather than 1 image
            $pagefiles = $page->getUnformatted($imageField->name);

            // if the image's pagefiles property matches the one with the field we're looking at, we have a match.
            if ($file->pagefiles === $pagefiles) {
                // return InputField (optional) in context of page template
                return $page->template->fieldgroup->getField($imageField->name, $useFieldgroupContext);
            }
        }

        return null;
    }

    /**
     * Return the DB schema used by this field's table
     *
     */
    public function getDatabaseSchema(Field $field)
    {
        $schema = parent::getDatabaseSchema($field);
//        $schema['focus'] = 'varchar(255) NOT NULL';
        $schema['focus'] = 'text NOT NULL';
        $schema['keys']['focus'] = 'FULLTEXT KEY focus (focus)';
        return $schema;
    }


    /**
     * Update database schema
     *
     * This method applies incremental updates until latest schema version is
     * reached, while also keeping schema_version config setting up to date.
     *
     */
    /*
    private function updateDatabaseSchema()
    {
        return;
//        $table_name = 'field_' . $this->name;
//        $this->warning('updateDatabaseSchema '. $this->name);
//        if(!$this->name) return;

        while ($this->schema_version < self::SCHEMA_VERSION) {
            ++$this->schema_version;
            switch ($this->schema_version) {
                case 2:
                    $sql = "ALTER TABLE " . $table_name . " CHANGE `focus` `focus` TEXT NOT NULL";
                    break;
                default:
                    throw new WireException("Unrecognized database schema version: $this->schema_version");
            }
            if ($sql && $this->db->query($sql)) {
                $configData = $this->modules->getModuleConfigData($this);
                $configData['schema_version'] = $this->schema_version;
                $this->modules->saveModuleConfigData($this, $configData);
                $this->warning('updated database schema to version ' . $this->schema_version);
            } else {
                throw new WireException("Couldn't update database schema to version $this->schema_version");
            }
        }
    }
*/

    /**
     * Given a raw value (value as stored in DB), return the value as it would appear in a Page object
     *
     * @param Page $page
     * @param Field $field
     * @param string|int|array $value
     *
     * @return string|int|array|object $value
     *
     */
    public function ___wakeupValue(Page $page, Field $field, $value)
    {

        $pagefiles = parent::___wakeupValue($page, $field, $value);

        foreach ($pagefiles as $pagefile) {
            foreach ($value as $v) {
                if ($v['data'] != $pagefile->basename) {
                    continue;
                }
                $pagefile->set('focus', $v['focus']);
            }
        }

        $pagefiles->resetTrackChanges(true);

        return $pagefiles;
    }

    /**
     * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB.
     *
     * @param Page $page
     * @param Field $field
     * @param string|int|array|object $value
     *
     * @return string|int
     *
     */
    public function ___sleepValue(Page $page, Field $field, $value)
    {
        $sleepValue = parent::___sleepValue($page, $field, $value);
        if(!$value instanceof Pagefiles) return $sleepValue;

        $key = 0;
        foreach ($value as $pagefile) {
            $sleepValue[$key]['focus'] = $value[$sleepValue[$key]['data']]->focus;
            $key++;
        }
        return $sleepValue;
    }

}

